{"ast":null,"code":"import { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => isFinite(+d[2]) ? +d[2] : 0,\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const {\n        points\n      } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n  let thresholds, values, triangulation;\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n  function* tricontours(points) {\n    init(points);\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n  function* isobands(points) {\n    init(points);\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(p0.concat(p1.map(ring => ring.slice().reverse()))),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n  const contours = function (data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => _ ? (x = _, contours) : x;\n  contours.y = _ => _ ? (y = _, contours) : y;\n  contours.value = _ => _ ? (value = _, contours) : value;\n  contours.thresholds = _ => _ ? (thresholds = _, contours) : thresholds;\n  contours.triangulate = _ => _ ? (triangulate = _, contours) : triangulate;\n  contours.pointInterpolate = _ => _ ? (pointInterpolate = _, contours) : pointInterpolate;\n  contours.ringsort = _ => _ ? (ringsort = _, contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n  function tricontour(triangulation, values) {\n    let v0 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n    const {\n        halfedges,\n        inedges,\n        triangles\n      } = triangulation,\n      n = values.length;\n    const Hull = new Map();\n    halfedges.forEach((i, j) => {\n      if (i === -1) Hull.set(triangles[j], triangles[j + (j % 3 === 2 ? -2 : 1)]);\n    });\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[j = next(i)]];\n\n        // is our tour done?\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti,\n          tj,\n          a\n        });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = triangles[i];\n          while (values[h] < v0) h = Hull.get(h);\n          while (values[h] >= v0) {\n            path.push({\n              ti: h,\n              tj: h,\n              a: 0\n            });\n            h = Hull.get(h);\n          }\n\n          // take that entry\n          j = inedges[h];\n          path.push({\n            ti: h,\n            tj: triangles[j],\n            a: alpha(h, triangles[j])\n          });\n          if (edgealpha(i = next(j)) > 0) continue;\n          if (edgealpha(i = prev(j)) > 0) continue;\n        }\n      }\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(_ref => {\n          let {\n            ti,\n            tj,\n            a\n          } = _ref;\n          return pointInterpolate(ti, tj, a);\n        }));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull (or hulls if\n    // there are multiple pieces or holes). Note: vacates the Hull Map.\n    do {\n      const ring = [];\n      let i = Hull.keys().next().value;\n      do {\n        const j = Hull.get(i);\n        ring.push(i);\n        Hull.delete(i);\n        i = j;\n      } while (Hull.has(i));\n      if (ring.every(i => values[i] >= v0)) {\n        ring.push(ring[0]);\n        rings.push(ring.map(i => pointInterpolate(i, i, 0)));\n      }\n    } while (Hull.size);\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","points","triangulation","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","tricontours","threshold","polygon","tricontour","type","coordinates","contour","isobands","p0","p1","th0","th","concat","map","ring","slice","reverse","valueMax","contours","data","_","_values","_triangulation","next","prev","v0","arguments","length","undefined","halfedges","inedges","triangles","n","Hull","Map","forEach","set","edgealpha","alpha","u","v","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","get","_ref","keys","delete","has","every","size"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/d3-tricontour/src/tricontour.js"],"sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, inedges, triangles } = triangulation,\n      n = values.length;\n\n    const Hull = new Map();\n    halfedges.forEach((i, j) => {\n      if (i === -1)\n        Hull.set(triangles[j], triangles[j + (j % 3 === 2 ? -2 : 1)]);\n    });\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && ti === path[0].ti && tj === path[0].tj) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = triangles[i];\n          while (values[h] < v0) h = Hull.get(h);\n          while (values[h] >= v0) {\n            path.push({ ti: h, tj: h, a: 0 });\n            h = Hull.get(h);\n          }\n\n          // take that entry\n          j = inedges[h];\n          path.push({ ti: h, tj: triangles[j], a: alpha(h, triangles[j]) });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull (or hulls if\n    // there are multiple pieces or holes). Note: vacates the Hull Map.\n    do {\n      const ring = [];\n      let i = Hull.keys().next().value;\n      do {\n        const j = Hull.get(i);\n        ring.push(i);\n        Hull.delete(i);\n        i = j;\n      } while (Hull.has(i));\n      if (ring.every((i) => values[i] >= v0)) {\n        ring.push(ring[0]);\n        rings.push(ring.map((i) => pointInterpolate(i, i, 0)));\n      }\n    } while (Hull.size);\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}