{"ast":null,"code":"import { geoDelaunay } from \"./delaunay.js\";\nimport { geoInterpolate } from \"d3-geo\";\nimport { tricontour } from \"d3-tricontour\";\nexport function geoContour() {\n  let v;\n  const contour = tricontour().triangulate((data, x, y) => {\n    v = geoDelaunay(data.map((d, i) => [x(d, i), y(d, i)]));\n    return v.delaunay;\n  }).pointInterpolate((i, j, a) => {\n    const {\n      points,\n      projection\n    } = v.delaunay;\n    const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n      B = projection.invert([points[2 * j], points[2 * j + 1]]);\n    return geoInterpolate(A, B)(a);\n  }).ringsort(rings => {\n    // tricky thing: in isobands this function is called twice,\n    // we want to reverse the polygons’s winding order only in tricontour()\n    // not in isoband()\n    if (rings.length && !rings[0].reversed) {\n      rings.forEach(ring => ring.reverse());\n      rings[0].reversed = true;\n    }\n    return [rings];\n  });\n  return contour;\n}","map":{"version":3,"names":["geoDelaunay","geoInterpolate","tricontour","geoContour","v","contour","triangulate","data","x","y","map","d","i","delaunay","pointInterpolate","j","a","points","projection","A","invert","B","ringsort","rings","length","reversed","forEach","ring","reverse"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/d3-geo-voronoi/src/contour.js"],"sourcesContent":["import { geoDelaunay } from \"./delaunay.js\";\nimport { geoInterpolate } from \"d3-geo\";\nimport { tricontour } from \"d3-tricontour\";\n\nexport function geoContour() {\n  let v;\n  const contour = tricontour()\n    .triangulate((data, x, y) => {\n      v = geoDelaunay(data.map((d, i) => [x(d, i), y(d, i)]));\n      return v.delaunay;\n    })\n    .pointInterpolate((i, j, a) => {\n      const { points, projection } = v.delaunay;\n      const A = projection.invert([points[2 * i], points[2 * i + 1]]),\n        B = projection.invert([points[2 * j], points[2 * j + 1]]);\n      return geoInterpolate(A, B)(a);\n    })\n    .ringsort((rings) => {\n      // tricky thing: in isobands this function is called twice,\n      // we want to reverse the polygons’s winding order only in tricontour()\n      // not in isoband()\n      if (rings.length && !rings[0].reversed) {\n        rings.forEach((ring) => ring.reverse());\n        rings[0].reversed = true;\n      }\n      return [rings];\n    });\n\n  return contour;\n}\n"],"mappings":"AAAA,SAASA,WAAW,QAAQ,eAAe;AAC3C,SAASC,cAAc,QAAQ,QAAQ;AACvC,SAASC,UAAU,QAAQ,eAAe;AAE1C,OAAO,SAASC,UAAUA,CAAA,EAAG;EAC3B,IAAIC,CAAC;EACL,MAAMC,OAAO,GAAGH,UAAU,CAAC,CAAC,CACzBI,WAAW,CAAC,CAACC,IAAI,EAAEC,CAAC,EAAEC,CAAC,KAAK;IAC3BL,CAAC,GAAGJ,WAAW,CAACO,IAAI,CAACG,GAAG,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK,CAACJ,CAAC,CAACG,CAAC,EAAEC,CAAC,CAAC,EAAEH,CAAC,CAACE,CAAC,EAAEC,CAAC,CAAC,CAAC,CAAC,CAAC;IACvD,OAAOR,CAAC,CAACS,QAAQ;EACnB,CAAC,CAAC,CACDC,gBAAgB,CAAC,CAACF,CAAC,EAAEG,CAAC,EAAEC,CAAC,KAAK;IAC7B,MAAM;MAAEC,MAAM;MAAEC;IAAW,CAAC,GAAGd,CAAC,CAACS,QAAQ;IACzC,MAAMM,CAAC,GAAGD,UAAU,CAACE,MAAM,CAAC,CAACH,MAAM,CAAC,CAAC,GAAGL,CAAC,CAAC,EAAEK,MAAM,CAAC,CAAC,GAAGL,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;MAC7DS,CAAC,GAAGH,UAAU,CAACE,MAAM,CAAC,CAACH,MAAM,CAAC,CAAC,GAAGF,CAAC,CAAC,EAAEE,MAAM,CAAC,CAAC,GAAGF,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IAC3D,OAAOd,cAAc,CAACkB,CAAC,EAAEE,CAAC,CAAC,CAACL,CAAC,CAAC;EAChC,CAAC,CAAC,CACDM,QAAQ,CAAEC,KAAK,IAAK;IACnB;IACA;IACA;IACA,IAAIA,KAAK,CAACC,MAAM,IAAI,CAACD,KAAK,CAAC,CAAC,CAAC,CAACE,QAAQ,EAAE;MACtCF,KAAK,CAACG,OAAO,CAAEC,IAAI,IAAKA,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC;MACvCL,KAAK,CAAC,CAAC,CAAC,CAACE,QAAQ,GAAG,IAAI;IAC1B;IACA,OAAO,CAACF,KAAK,CAAC;EAChB,CAAC,CAAC;EAEJ,OAAOlB,OAAO;AAChB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}