{"ast":null,"code":"import { FileLoader, Loader, ShapePath } from 'three';\n\n/**\n * A loader for loading fonts.\n *\n * You can convert fonts online using [facetype.js](https://gero3.github.io/facetype.js/).\n *\n * ```js\n * const loader = new FontLoader();\n * const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );\n * ```\n *\n * @augments Loader\n * @three_import import { FontLoader } from 'three/addons/loaders/FontLoader.js';\n */\nclass FontLoader extends Loader {\n  /**\n   * Constructs a new font loader.\n   *\n   * @param {LoadingManager} [manager] - The loading manager.\n   */\n  constructor(manager) {\n    super(manager);\n  }\n\n  /**\n   * Starts loading from the given URL and passes the loaded font\n   * to the `onLoad()` callback.\n   *\n   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n   * @param {function(Font)} onLoad - Executed when the loading process has been finished.\n   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n   * @param {onErrorCallback} onError - Executed when errors occur.\n   */\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      const font = scope.parse(JSON.parse(text));\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  /**\n   * Parses the given font data and returns the resulting font.\n   *\n   * @param {Object} json - The raw font data as a JSON object.\n   * @return {Font} The font.\n   */\n  parse(json) {\n    return new Font(json);\n  }\n}\n\n/**\n * Class representing a font.\n */\nclass Font {\n  /**\n   * Constructs a new font.\n   *\n   * @param {Object} data - The font data as JSON.\n   */\n  constructor(data) {\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isFont = true;\n    this.type = 'Font';\n\n    /**\n     * The font data as JSON.\n     *\n     * @type {Object}\n     */\n    this.data = data;\n  }\n\n  /**\n   * Generates geometry shapes from the given text and size. The result of this method\n   * should be used with {@link ShapeGeometry} to generate the actual geometry data.\n   *\n   * @param {string} text - The text.\n   * @param {number} [size=100] - The text size.\n   * @param {string} [direction='ltr'] - Char direction: ltr(left to right), rtl(right to left) & tb(top bottom).\n   * @return {Array<Shape>} An array of shapes representing the text.\n   */\n  generateShapes(text) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'ltr';\n    const shapes = [];\n    const paths = createPaths(text, size, this.data, direction);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      shapes.push(...paths[p].toShapes());\n    }\n    return shapes;\n  }\n}\nfunction createPaths(text, size, data, direction) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n    offsetY = 0;\n  if (direction == 'rtl' || direction == 'tb') {\n    chars.reverse();\n  }\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      if (direction == 'tb') {\n        offsetX = 0;\n        offsetY += data.ascender * scale;\n      } else {\n        offsetX += ret.offsetX;\n      }\n      paths.push(ret.path);\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n      switch (action) {\n        case 'm':\n          // moveTo\n\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case 'l':\n          // lineTo\n\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case 'q':\n          // quadraticCurveTo\n\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case 'b':\n          // bezierCurveTo\n\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          cpx2 = outline[i++] * scale + offsetX;\n          cpy2 = outline[i++] * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {\n    offsetX: glyph.ha * scale,\n    path: path\n  };\n}\nexport { FontLoader, Font };","map":{"version":3,"names":["FileLoader","Loader","ShapePath","FontLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","font","parse","JSON","json","Font","data","isFont","type","generateShapes","size","arguments","length","undefined","direction","shapes","paths","createPaths","p","pl","push","toShapes","chars","Array","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","reverse","i","char","ret","createPath","ascender","glyph","glyphs","console","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/globe.gl/node_modules/three/examples/jsm/loaders/FontLoader.js"],"sourcesContent":["import {\n\tFileLoader,\n\tLoader,\n\tShapePath\n} from 'three';\n\n/**\n * A loader for loading fonts.\n *\n * You can convert fonts online using [facetype.js](https://gero3.github.io/facetype.js/).\n *\n * ```js\n * const loader = new FontLoader();\n * const font = await loader.loadAsync( 'fonts/helvetiker_regular.typeface.json' );\n * ```\n *\n * @augments Loader\n * @three_import import { FontLoader } from 'three/addons/loaders/FontLoader.js';\n */\nclass FontLoader extends Loader {\n\n\t/**\n\t * Constructs a new font loader.\n\t *\n\t * @param {LoadingManager} [manager] - The loading manager.\n\t */\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\t/**\n\t * Starts loading from the given URL and passes the loaded font\n\t * to the `onLoad()` callback.\n\t *\n\t * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.\n\t * @param {function(Font)} onLoad - Executed when the loading process has been finished.\n\t * @param {onProgressCallback} onProgress - Executed while the loading is in progress.\n\t * @param {onErrorCallback} onError - Executed when errors occur.\n\t */\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( this.manager );\n\t\tloader.setPath( this.path );\n\t\tloader.setRequestHeader( this.requestHeader );\n\t\tloader.setWithCredentials( this.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tconst font = scope.parse( JSON.parse( text ) );\n\n\t\t\tif ( onLoad ) onLoad( font );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\t/**\n\t * Parses the given font data and returns the resulting font.\n\t *\n\t * @param {Object} json - The raw font data as a JSON object.\n\t * @return {Font} The font.\n\t */\n\tparse( json ) {\n\n\t\treturn new Font( json );\n\n\t}\n\n}\n\n/**\n * Class representing a font.\n */\nclass Font {\n\n\t/**\n\t * Constructs a new font.\n\t *\n\t * @param {Object} data - The font data as JSON.\n\t */\n\tconstructor( data ) {\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isFont = true;\n\n\t\tthis.type = 'Font';\n\n\t\t/**\n\t\t * The font data as JSON.\n\t\t *\n\t\t * @type {Object}\n\t\t */\n\t\tthis.data = data;\n\n\t}\n\n\t/**\n\t * Generates geometry shapes from the given text and size. The result of this method\n\t * should be used with {@link ShapeGeometry} to generate the actual geometry data.\n\t *\n\t * @param {string} text - The text.\n\t * @param {number} [size=100] - The text size.\n\t * @param {string} [direction='ltr'] - Char direction: ltr(left to right), rtl(right to left) & tb(top bottom).\n\t * @return {Array<Shape>} An array of shapes representing the text.\n\t */\n\tgenerateShapes( text, size = 100, direction = 'ltr' ) {\n\n\t\tconst shapes = [];\n\t\tconst paths = createPaths( text, size, this.data, direction );\n\n\t\tfor ( let p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\t\tshapes.push( ...paths[ p ].toShapes() );\n\n\t\t}\n\n\t\treturn shapes;\n\n\t}\n\n}\n\nfunction createPaths( text, size, data, direction ) {\n\n\tconst chars = Array.from( text );\n\tconst scale = size / data.resolution;\n\tconst line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\n\n\tconst paths = [];\n\n\tlet offsetX = 0, offsetY = 0;\n\n\tif ( direction == 'rtl' || direction == 'tb' ) {\n\n\t\tchars.reverse();\n\n\t}\n\n\tfor ( let i = 0; i < chars.length; i ++ ) {\n\n\t\tconst char = chars[ i ];\n\n\t\tif ( char === '\\n' ) {\n\n\t\t\toffsetX = 0;\n\t\t\toffsetY -= line_height;\n\n\t\t} else {\n\n\t\t\tconst ret = createPath( char, scale, offsetX, offsetY, data );\n\n\t\t\tif ( direction == 'tb' ) {\n\n\t\t\t\toffsetX = 0;\n\t\t\t\toffsetY += data.ascender * scale;\n\n\t\t\t} else {\n\n\t\t\t\toffsetX += ret.offsetX;\n\n\t\t\t}\n\n\t\t\tpaths.push( ret.path );\n\n\t\t}\n\n\t}\n\n\treturn paths;\n\n}\n\nfunction createPath( char, scale, offsetX, offsetY, data ) {\n\n\tconst glyph = data.glyphs[ char ] || data.glyphs[ '?' ];\n\n\tif ( ! glyph ) {\n\n\t\tconsole.error( 'THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.' );\n\n\t\treturn;\n\n\t}\n\n\tconst path = new ShapePath();\n\n\tlet x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n\tif ( glyph.o ) {\n\n\t\tconst outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\n\t\tfor ( let i = 0, l = outline.length; i < l; ) {\n\n\t\t\tconst action = outline[ i ++ ];\n\n\t\t\tswitch ( action ) {\n\n\t\t\t\tcase 'm': // moveTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l': // lineTo\n\n\t\t\t\t\tx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\ty = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q': // quadraticCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'b': // bezierCurveTo\n\n\t\t\t\t\tcpx = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy1 = outline[ i ++ ] * scale + offsetY;\n\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offsetX;\n\t\t\t\t\tcpy2 = outline[ i ++ ] * scale + offsetY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn { offsetX: glyph.ha * scale, path: path };\n\n}\n\nexport { FontLoader, Font };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}