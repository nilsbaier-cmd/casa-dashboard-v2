{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, extent, mean } from 'd3-array';\nimport earcut, { flatten } from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\nimport { scaleLinear } from 'd3-scale';\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ;else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === undefined ? Infinity : _ref$resolution;\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds = geoBounds(boundariesGeojson),\n    _geoBounds2 = _slicedToArray(_geoBounds, 2),\n    _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n    minLng = _geoBounds2$[0],\n    minLat = _geoBounds2$[1],\n    _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n    maxLng = _geoBounds2$2[0],\n    maxLat = _geoBounds2$2[1];\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        lng = _ref3[0],\n        lat = _ref3[1];\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          lng = _ref5[0],\n          lat = _ref5[1];\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcutFlatten = flatten(contour),\n      vertices = _earcutFlatten.vertices,\n      _earcutFlatten$holes = _earcutFlatten.holes,\n      holes = _earcutFlatten$holes === undefined ? [] : _earcutFlatten$holes;\n    indices = earcut(vertices, holes, 2);\n  } else {\n    // use delaunator\n    var delaunay = Delaunator.from(points);\n    var _loop = function _loop(i) {\n      var _indices2;\n      var inds = [2, 1, 0].map(function (idx) {\n        return delaunay.triangles[i + idx];\n      }); // reverse wound to have same orientation as earcut\n      var triangle = inds.map(function (indice) {\n        return points[indice];\n      });\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = [0, 1].map(function (coordIdx) {\n          return mean(triangle, function (p) {\n            return p[coordIdx];\n          });\n        });\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return 1; // continue\n      }\n      (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n    };\n    for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n      if (_loop(i)) continue;\n    }\n  }\n\n  // calc uvs\n  var lngUvScale = scaleLinear(extent(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = scaleLinear(extent(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      lng = _ref7[0],\n      lat = _ref7[1];\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n    _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n    _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n    minLng = _geoBounds4$[0],\n    minLat = _geoBounds4$[1],\n    _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n    maxLng = _geoBounds4$2[0],\n    maxLat = _geoBounds4$2[1];\n\n  // polygon smaller than maxDistance -> no inner points\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    minLng = _ref8.minLng,\n    maxLng = _ref8.maxLng,\n    minLat = _ref8.minLat,\n    maxLat = _ref8.maxLat;\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);\n\n  // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n  return pnts;\n}\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar ConicPolygonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function ConicPolygonGeometry(polygonGeoJson, bottomHeight, topHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n    _classCallCheck(this, ConicPolygonGeometry);\n    _this = _callSuper(this, ConicPolygonGeometry);\n    _this.type = 'ConicPolygonGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      bottomHeight: bottomHeight,\n      topHeight: topHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    };\n\n    // defaults\n    bottomHeight = bottomHeight || 0;\n    topHeight = topHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n\n    // pre-calculate contour, triangulation and UV maps\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n        resolution: curvatureResolution\n      }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n    var flatUvs = merge(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(bottomHeight, false));\n    closedTop && addGroup(generateCap(topHeight, true));\n\n    // build geometry\n    _this.setIndex(indices);\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\n    // auto-calculate normals\n    _this.computeVertexNormals();\n\n    //\n\n    function generateVertices(polygon, altitude) {\n      var altFn = typeof altitude === 'function' ? altitude : function () {\n        return altitude;\n      };\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n          return polar2Cartesian(lat, lng, altFn(lng, lat));\n        });\n      });\n      // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n      return flatten(coords3d);\n    }\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, bottomHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n      var _generateVertices2 = generateVertices(contour, topHeight),\n        topVerts = _generateVertices2.vertices;\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n          lastHoleIdx = holeIdx;\n        }\n\n        // Each pair of coords generates two triangles (faces)\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n      for (var v = 1; v >= 0; v--) for (var i = 0; i < numPoints; i += 1) uvs.push(i / (numPoints - 1), v);\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n    return _this;\n  }\n  _inherits(ConicPolygonGeometry, _THREE$BufferGeometry);\n  return _createClass(ConicPolygonGeometry);\n}(THREE.BufferGeometry); //\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\nexport { ConicPolygonGeometry as default };","map":{"version":3,"names":["BufferGeometry","Float32BufferAttribute","merge","extent","mean","earcut","flatten","Delaunator","turfPointInPolygon","geoBounds","geoContains","geoDistance","geoInterpolate","geoVoronoi","scaleLinear","_arrayLikeToArray","r","a","length","e","n","Array","_arrayWithHoles","isArray","_arrayWithoutHoles","_assertThisInitialized","undefined","ReferenceError","_callSuper","t","o","_getPrototypeOf","_possibleConstructorReturn","_isNativeReflectConstruct","Reflect","construct","constructor","apply","_classCallCheck","TypeError","_createClass","Object","defineProperty","writable","setPrototypeOf","getPrototypeOf","bind","__proto__","_inherits","prototype","create","value","configurable","_setPrototypeOf","Boolean","valueOf","call","_iterableToArray","Symbol","iterator","from","_iterableToArrayLimit","l","i","u","f","next","done","push","return","_nonIterableRest","_nonIterableSpread","_slicedToArray","_unsupportedIterableToArray","_toConsumableArray","toString","slice","name","test","geoPolygonTriangulate","polygon","_ref","arguments","_ref$resolution","resolution","Infinity","contour","interpolateContourPoints","edgePoints","innerPoints","getInnerGeoPoints","points","concat","boundariesGeojson","type","coordinates","_geoBounds","_geoBounds2","_geoBounds2$","minLng","minLat","_geoBounds2$2","maxLng","maxLat","crossesPoleOrAntimeridian","indices","vt","triangles","pntMap","Map","map","_ref2","idx","_ref3","lng","lat","features","forEach","_indices","triangle","geometry","reverse","inds","_ref4","_ref5","k","has","get","some","ind","triangleCentroid","properties","circumcenter","pointInside","_earcutFlatten","vertices","_earcutFlatten$holes","holes","delaunay","_loop","_indices2","indice","coordIdx","p","len","lngUvScale","d","latUvScale","uvs","_ref6","_ref7","maxDistance","coords","pnts","prevPnt","pnt","dist","Math","PI","interpol","tStep","ceil","_geoBounds3","_geoBounds4","_geoBounds4$","_geoBounds4$2","min","abs","getGeoSpiralGrid","filter","distanceBetweenPoints","_ref8","numPoints","round","pow","phi","sqrt","getPntLng","getPntLat","acos","getPntIdx","cos","pntIdxRange","floor","isLngInRange","THREE","window","setAttributeFn","setAttribute","ConicPolygonGeometry","_THREE$BufferGeometry","polygonGeoJson","bottomHeight","topHeight","closedBottom","closedTop","includeSides","curvatureResolution","_this","parameters","_geoPolygonTriangulat","flatUvs","groupCnt","addGroup","groupData","prevVertCnt","prevIndCnt","generateTorso","generateCap","setIndex","computeVertexNormals","generateVertices","altitude","altFn","coords3d","polar2Cartesian","_generateVertices","bottomVerts","_generateVertices2","topVerts","holesIdx","Set","lastHoleIdx","v0Idx","v1Idx","holeIdx","v","radius","isTop","theta","sin","default"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs"],"sourcesContent":["import { BufferGeometry, Float32BufferAttribute } from 'three';\nimport { merge, extent, mean } from 'd3-array';\nimport earcut, { flatten } from 'earcut';\nimport Delaunator from 'delaunator';\nimport turfPointInPolygon from '@turf/boolean-point-in-polygon';\nimport { geoBounds, geoContains, geoDistance, geoInterpolate } from 'd3-geo';\nimport { geoVoronoi } from 'd3-geo-voronoi';\nimport { scaleLinear } from 'd3-scale';\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithHoles(r) {\n  if (Array.isArray(r)) return r;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _assertThisInitialized(e) {\n  if (undefined === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _createClass(e, r, t) {\n  return Object.defineProperty(e, \"prototype\", {\n    writable: false\n  }), e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: true,\n      configurable: true\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: false\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = true,\n      o = false;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) ; else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = true, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (undefined !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _slicedToArray(r, e) {\n  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nfunction geoPolygonTriangulate(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$resolution = _ref.resolution,\n    resolution = _ref$resolution === undefined ? Infinity : _ref$resolution;\n  var contour = interpolateContourPoints(polygon, resolution);\n  var edgePoints = merge(contour);\n  var innerPoints = getInnerGeoPoints(polygon, resolution);\n  var points = [].concat(_toConsumableArray(edgePoints), _toConsumableArray(innerPoints));\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds = geoBounds(boundariesGeojson),\n    _geoBounds2 = _slicedToArray(_geoBounds, 2),\n    _geoBounds2$ = _slicedToArray(_geoBounds2[0], 2),\n    minLng = _geoBounds2$[0],\n    minLat = _geoBounds2$[1],\n    _geoBounds2$2 = _slicedToArray(_geoBounds2[1], 2),\n    maxLng = _geoBounds2$2[0],\n    maxLat = _geoBounds2$2[1];\n  var crossesPoleOrAntimeridian = minLng > maxLng // crosses antimeridian\n  || maxLat >= 89 // crosses north pole\n  || minLat <= -89; // crosses south pole\n\n  var indices = [];\n  if (crossesPoleOrAntimeridian) {\n    // Use d3-geo-voronoi. Slowest, but most accurate for polygons that cross poles or anti-meridian\n    var vt = geoVoronoi(points).triangles(); // geoDelaunay generates more triangles than needed\n    var pntMap = new Map(points.map(function (_ref2, idx) {\n      var _ref3 = _slicedToArray(_ref2, 2),\n        lng = _ref3[0],\n        lat = _ref3[1];\n      return [\"\".concat(lng, \"-\").concat(lat), idx];\n    }));\n    vt.features.forEach(function (f) {\n      var _indices;\n      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse(); // reverse wound to match earcut\n\n      var inds = [];\n      triangle.forEach(function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 2),\n          lng = _ref5[0],\n          lat = _ref5[1];\n        var k = \"\".concat(lng, \"-\").concat(lat);\n        pntMap.has(k) && inds.push(pntMap.get(k));\n      });\n      if (inds.length !== 3) return; // triangle malfunction\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = f.properties.circumcenter;\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;\n      }\n      (_indices = indices).push.apply(_indices, inds);\n    });\n  } else if (!innerPoints.length) {\n    // earcut triangulation slightly more performing if it's only using the polygon perimeter\n    var _earcutFlatten = flatten(contour),\n      vertices = _earcutFlatten.vertices,\n      _earcutFlatten$holes = _earcutFlatten.holes,\n      holes = _earcutFlatten$holes === undefined ? [] : _earcutFlatten$holes;\n    indices = earcut(vertices, holes, 2);\n  } else {\n    // use delaunator\n    var delaunay = Delaunator.from(points);\n    var _loop = function _loop(i) {\n      var _indices2;\n      var inds = [2, 1, 0].map(function (idx) {\n        return delaunay.triangles[i + idx];\n      }); // reverse wound to have same orientation as earcut\n      var triangle = inds.map(function (indice) {\n        return points[indice];\n      });\n\n      // exclude edge triangles outside polygon perimeter or through holes\n      if (inds.some(function (ind) {\n        return ind < edgePoints.length;\n      })) {\n        var triangleCentroid = [0, 1].map(function (coordIdx) {\n          return mean(triangle, function (p) {\n            return p[coordIdx];\n          });\n        });\n        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return 1; // continue\n      }\n      (_indices2 = indices).push.apply(_indices2, _toConsumableArray(inds));\n    };\n    for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {\n      if (_loop(i)) continue;\n    }\n  }\n\n  // calc uvs\n  var lngUvScale = scaleLinear(extent(points, function (d) {\n    return d[0];\n  }), [0, 1]);\n  var latUvScale = scaleLinear(extent(points, function (d) {\n    return d[1];\n  }), [0, 1]);\n  var uvs = points.map(function (_ref6) {\n    var _ref7 = _slicedToArray(_ref6, 2),\n      lng = _ref7[0],\n      lat = _ref7[1];\n    return [lngUvScale(lng), latUvScale(lat)];\n  });\n  var triangles = {\n    points: points,\n    indices: indices,\n    uvs: uvs\n  };\n  return {\n    contour: contour,\n    triangles: triangles\n  };\n}\nfunction interpolateContourPoints(polygon, maxDistance) {\n  // add interpolated points for segments that are further apart than the max distance\n  return polygon.map(function (coords) {\n    var pnts = [];\n    var prevPnt;\n    coords.forEach(function (pnt) {\n      if (prevPnt) {\n        var dist = geoDistance(pnt, prevPnt) * 180 / Math.PI;\n        if (dist > maxDistance) {\n          var interpol = geoInterpolate(prevPnt, pnt);\n          var tStep = 1 / Math.ceil(dist / maxDistance);\n          var t = tStep;\n          while (t < 1) {\n            pnts.push(interpol(t));\n            t += tStep;\n          }\n        }\n      }\n      pnts.push(prevPnt = pnt);\n    });\n    return pnts;\n  });\n}\nfunction getInnerGeoPoints(polygon, maxDistance) {\n  var boundariesGeojson = {\n    type: 'Polygon',\n    coordinates: polygon\n  };\n  var _geoBounds3 = geoBounds(boundariesGeojson),\n    _geoBounds4 = _slicedToArray(_geoBounds3, 2),\n    _geoBounds4$ = _slicedToArray(_geoBounds4[0], 2),\n    minLng = _geoBounds4$[0],\n    minLat = _geoBounds4$[1],\n    _geoBounds4$2 = _slicedToArray(_geoBounds4[1], 2),\n    maxLng = _geoBounds4$2[0],\n    maxLat = _geoBounds4$2[1];\n\n  // polygon smaller than maxDistance -> no inner points\n  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];\n  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;\n  return getGeoSpiralGrid(maxDistance, {\n    minLng: minLng,\n    maxLng: maxLng,\n    minLat: minLat,\n    maxLat: maxLat\n  }).filter(function (pnt) {\n    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);\n  });\n}\nfunction getGeoSpiralGrid(distanceBetweenPoints) {\n  var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    minLng = _ref8.minLng,\n    maxLng = _ref8.maxLng,\n    minLat = _ref8.minLat,\n    maxLat = _ref8.maxLat;\n  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);\n\n  // https://observablehq.com/@mbostock/spherical-fibonacci-lattice\n  var phi = (1 + Math.sqrt(5)) / 2; // golden ratio\n\n  var getPntLng = function getPntLng(idx) {\n    return idx / phi * 360 % 360 - 180;\n  };\n  var getPntLat = function getPntLat(idx) {\n    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;\n  };\n  var getPntIdx = function getPntIdx(lat) {\n    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;\n  };\n  var pntIdxRange = [maxLat !== undefined ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== undefined ? Math.floor(getPntIdx(minLat)) : numPoints - 1];\n  var isLngInRange = minLng === undefined && maxLng === undefined ? function () {\n    return true;\n  } : minLng === undefined ? function (lng) {\n    return lng <= maxLng;\n  } : maxLng === undefined ? function (lng) {\n    return lng >= minLng;\n  } : maxLng >= minLng ? function (lng) {\n    return lng >= minLng && lng <= maxLng;\n  } : function (lng) {\n    return lng >= minLng || lng <= maxLng;\n  }; // for ranges that cross the anti-meridian\n\n  var pnts = [];\n  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {\n    var lng = getPntLng(i);\n    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);\n  }\n  return pnts;\n}\nfunction pointInside(pnt, polygon) {\n  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // turf method is more performing but malfunctions if polygon includes a pole (lat = 90 | -90) or crosses the antimeridian (lng = 180 | -180)\n  return crossesPoleOrAntimeridian ? geoContains(polygon, pnt) : turfPointInPolygon(pnt, polygon);\n}\n\nvar THREE = window.THREE ? window.THREE // Prefer consumption from global THREE, if exists\n: {\n  BufferGeometry: BufferGeometry,\n  Float32BufferAttribute: Float32BufferAttribute\n};\n\n// support both modes for backwards threejs compatibility\nvar setAttributeFn = new THREE.BufferGeometry().setAttribute ? 'setAttribute' : 'addAttribute';\nvar ConicPolygonGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {\n  function ConicPolygonGeometry(polygonGeoJson, bottomHeight, topHeight, closedBottom, closedTop, includeSides, curvatureResolution) {\n    var _this;\n    _classCallCheck(this, ConicPolygonGeometry);\n    _this = _callSuper(this, ConicPolygonGeometry);\n    _this.type = 'ConicPolygonGeometry';\n    _this.parameters = {\n      polygonGeoJson: polygonGeoJson,\n      bottomHeight: bottomHeight,\n      topHeight: topHeight,\n      closedBottom: closedBottom,\n      closedTop: closedTop,\n      includeSides: includeSides,\n      curvatureResolution: curvatureResolution\n    };\n\n    // defaults\n    bottomHeight = bottomHeight || 0;\n    topHeight = topHeight || 1;\n    closedBottom = closedBottom !== undefined ? closedBottom : true;\n    closedTop = closedTop !== undefined ? closedTop : true;\n    includeSides = includeSides !== undefined ? includeSides : true;\n    curvatureResolution = curvatureResolution || 5; // in angular degrees\n\n    // pre-calculate contour, triangulation and UV maps\n    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {\n        resolution: curvatureResolution\n      }),\n      contour = _geoPolygonTriangulat.contour,\n      triangles = _geoPolygonTriangulat.triangles;\n    var flatUvs = merge(triangles.uvs);\n    var vertices = [];\n    var uvs = [];\n    var indices = [];\n    var groupCnt = 0; // add groups to apply different materials to torso / caps\n\n    var addGroup = function addGroup(groupData) {\n      var prevVertCnt = Math.round(vertices.length / 3);\n      var prevIndCnt = indices.length;\n      vertices = vertices.concat(groupData.vertices);\n      uvs = uvs.concat(groupData.uvs);\n      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function (ind) {\n        return ind + prevVertCnt;\n      }));\n      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);\n    };\n    includeSides && addGroup(generateTorso());\n    closedBottom && addGroup(generateCap(bottomHeight, false));\n    closedTop && addGroup(generateCap(topHeight, true));\n\n    // build geometry\n    _this.setIndex(indices);\n    _this[setAttributeFn]('position', new THREE.Float32BufferAttribute(vertices, 3));\n    _this[setAttributeFn]('uv', new THREE.Float32BufferAttribute(uvs, 2));\n\n    // auto-calculate normals\n    _this.computeVertexNormals();\n\n    //\n\n    function generateVertices(polygon, altitude) {\n      var altFn = typeof altitude === 'function' ? altitude : function () {\n        return altitude;\n      };\n      var coords3d = polygon.map(function (coords) {\n        return coords.map(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n            lng = _ref2[0],\n            lat = _ref2[1];\n          return polar2Cartesian(lat, lng, altFn(lng, lat));\n        });\n      });\n      // returns { vertices, holes, coordinates }. Each point generates 3 vertice items (x,y,z).\n      return flatten(coords3d);\n    }\n    function generateTorso() {\n      var _generateVertices = generateVertices(contour, bottomHeight),\n        bottomVerts = _generateVertices.vertices,\n        holes = _generateVertices.holes;\n      var _generateVertices2 = generateVertices(contour, topHeight),\n        topVerts = _generateVertices2.vertices;\n      var vertices = merge([topVerts, bottomVerts]);\n      var numPoints = Math.round(topVerts.length / 3);\n      var holesIdx = new Set(holes);\n      var lastHoleIdx = 0;\n      var indices = [];\n      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {\n        var v1Idx = v0Idx + 1; // next point\n        if (v1Idx === numPoints) {\n          v1Idx = lastHoleIdx; // close final loop\n        } else if (holesIdx.has(v1Idx)) {\n          var holeIdx = v1Idx;\n          v1Idx = lastHoleIdx; // close hole loop\n          lastHoleIdx = holeIdx;\n        }\n\n        // Each pair of coords generates two triangles (faces)\n        indices.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);\n        indices.push(v1Idx + numPoints, v1Idx, v0Idx);\n      }\n      var uvs = []; // wrap texture around perimeter (u), with v=1 on top\n      for (var v = 1; v >= 0; v--) for (var i = 0; i < numPoints; i += 1) uvs.push(i / (numPoints - 1), v);\n      return {\n        indices: indices,\n        vertices: vertices,\n        uvs: uvs\n      };\n    }\n    function generateCap(radius) {\n      var isTop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return {\n        // need to reverse-wind the bottom triangles to make them face outwards\n        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),\n        vertices: generateVertices([triangles.points], radius).vertices,\n        uvs: flatUvs\n      };\n    }\n    return _this;\n  }\n  _inherits(ConicPolygonGeometry, _THREE$BufferGeometry);\n  return _createClass(ConicPolygonGeometry);\n}(THREE.BufferGeometry); //\nfunction polar2Cartesian(lat, lng) {\n  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var phi = (90 - lat) * Math.PI / 180;\n  var theta = (90 - lng) * Math.PI / 180;\n  return [r * Math.sin(phi) * Math.cos(theta),\n  // x\n  r * Math.cos(phi),\n  // y\n  r * Math.sin(phi) * Math.sin(theta) // z\n  ];\n}\n\nexport { ConicPolygonGeometry as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}