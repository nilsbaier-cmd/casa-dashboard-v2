{"ast":null,"code":"import { Box3, InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Sphere, Vector3, Vector4 } from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\nconst _viewport = new Vector4();\nconst _start = new Vector3();\nconst _end = new Vector3();\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth(camera, distance, resolution) {\n  // transform into clip space, adjust the x and y values by the pixel width offset, then\n  // transform back into world space to get world offset. Note clip space is [-1, 1] so full\n  // width does not need to be halved.\n  _clipToWorldVector.set(0, 0, -distance, 1.0).applyMatrix4(camera.projectionMatrix);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  _clipToWorldVector.x = _lineWidth / resolution.width;\n  _clipToWorldVector.y = _lineWidth / resolution.height;\n  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);\n  _clipToWorldVector.multiplyScalar(1.0 / _clipToWorldVector.w);\n  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));\n}\nfunction raycastWorldUnits(lineSegments, intersects) {\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _line.start.fromBufferAttribute(instanceStart, i);\n    _line.end.fromBufferAttribute(instanceEnd, i);\n    _line.applyMatrix4(matrixWorld);\n    const pointOnLine = new Vector3();\n    const point = new Vector3();\n    _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n    const isInside = point.distanceTo(pointOnLine) < _lineWidth * 0.5;\n    if (isInside) {\n      intersects.push({\n        point,\n        pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv1: null\n      });\n    }\n  }\n}\nfunction raycastScreenSpace(lineSegments, camera, intersects) {\n  const projectionMatrix = camera.projectionMatrix;\n  const material = lineSegments.material;\n  const resolution = material.resolution;\n  const matrixWorld = lineSegments.matrixWorld;\n  const geometry = lineSegments.geometry;\n  const instanceStart = geometry.attributes.instanceStart;\n  const instanceEnd = geometry.attributes.instanceEnd;\n  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);\n  const near = -camera.near;\n\n  //\n\n  // pick a point 1 unit out along the ray to avoid the ray origin\n  // sitting at the camera origin which will cause \"w\" to be 0 when\n  // applying the projection matrix.\n  _ray.at(1, _ssOrigin);\n\n  // ndc space [ - 1.0, 1.0 ]\n  _ssOrigin.w = 1;\n  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n  _ssOrigin.applyMatrix4(projectionMatrix);\n  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);\n\n  // screen space\n  _ssOrigin.x *= resolution.x / 2;\n  _ssOrigin.y *= resolution.y / 2;\n  _ssOrigin.z = 0;\n  _ssOrigin3.copy(_ssOrigin);\n  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n  for (let i = 0, l = segmentCount; i < l; i++) {\n    _start4.fromBufferAttribute(instanceStart, i);\n    _end4.fromBufferAttribute(instanceEnd, i);\n    _start4.w = 1;\n    _end4.w = 1;\n\n    // camera space\n    _start4.applyMatrix4(_mvMatrix);\n    _end4.applyMatrix4(_mvMatrix);\n\n    // skip the segment if it's entirely behind the camera\n    const isBehindCameraNear = _start4.z > near && _end4.z > near;\n    if (isBehindCameraNear) {\n      continue;\n    }\n\n    // trim the segment if it extends behind camera near\n    if (_start4.z > near) {\n      const deltaDist = _start4.z - _end4.z;\n      const t = (_start4.z - near) / deltaDist;\n      _start4.lerp(_end4, t);\n    } else if (_end4.z > near) {\n      const deltaDist = _end4.z - _start4.z;\n      const t = (_end4.z - near) / deltaDist;\n      _end4.lerp(_start4, t);\n    }\n\n    // clip space\n    _start4.applyMatrix4(projectionMatrix);\n    _end4.applyMatrix4(projectionMatrix);\n\n    // ndc space [ - 1.0, 1.0 ]\n    _start4.multiplyScalar(1 / _start4.w);\n    _end4.multiplyScalar(1 / _end4.w);\n\n    // screen space\n    _start4.x *= resolution.x / 2;\n    _start4.y *= resolution.y / 2;\n    _end4.x *= resolution.x / 2;\n    _end4.y *= resolution.y / 2;\n\n    // create 2d segment\n    _line.start.copy(_start4);\n    _line.start.z = 0;\n    _line.end.copy(_end4);\n    _line.end.z = 0;\n\n    // get closest point on ray to segment\n    const param = _line.closestPointToPointParameter(_ssOrigin3, true);\n    _line.at(param, _closestPoint);\n\n    // check if the intersection point is within clip space\n    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);\n    const isInClipSpace = zPos >= -1 && zPos <= 1;\n    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;\n    if (isInClipSpace && isInside) {\n      _line.start.fromBufferAttribute(instanceStart, i);\n      _line.end.fromBufferAttribute(instanceEnd, i);\n      _line.start.applyMatrix4(matrixWorld);\n      _line.end.applyMatrix4(matrixWorld);\n      const pointOnLine = new Vector3();\n      const point = new Vector3();\n      _ray.distanceSqToSegment(_line.start, _line.end, point, pointOnLine);\n      intersects.push({\n        point: point,\n        pointOnLine: pointOnLine,\n        distance: _ray.origin.distanceTo(point),\n        object: lineSegments,\n        face: null,\n        faceIndex: i,\n        uv: null,\n        uv1: null\n      });\n    }\n  }\n}\n\n/**\n * A series of lines drawn between pairs of vertices.\n *\n * This adds functionality beyond {@link LineSegments}, like arbitrary line width and changing width\n * to be in world units. {@link Line2} extends this object, forming a polyline instead of individual\n * segments.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `lines/webgpu/LineSegments2.js`.\n *\n *  ```js\n * const geometry = new LineSegmentsGeometry();\n * geometry.setPositions( positions );\n * geometry.setColors( colors );\n *\n * const material = new LineMaterial( { linewidth: 5, vertexColors: true } };\n *\n * const lineSegments = new LineSegments2( geometry, material );\n * scene.add( lineSegments );\n * ```\n *\n * @augments Mesh\n * @three_import import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';\n */\nclass LineSegments2 extends Mesh {\n  /**\n   * Constructs a new wide line.\n   *\n   * @param {LineSegmentsGeometry} [geometry] - The line geometry.\n   * @param {LineMaterial} [material] - The line material.\n   */\n  constructor() {\n    let geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new LineSegmentsGeometry();\n    let material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineMaterial({\n      color: Math.random() * 0xffffff\n    });\n    super(geometry, material);\n\n    /**\n     * This flag can be used for type testing.\n     *\n     * @type {boolean}\n     * @readonly\n     * @default true\n     */\n    this.isLineSegments2 = true;\n    this.type = 'LineSegments2';\n  }\n\n  /**\n   * Computes an array of distance values which are necessary for rendering dashed lines.\n   * For each vertex in the geometry, the method calculates the cumulative length from the\n   * current point to the very beginning of the line.\n   *\n   * @return {LineSegments2} A reference to this instance.\n   */\n  computeLineDistances() {\n    // for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n    const geometry = this.geometry;\n    const instanceStart = geometry.attributes.instanceStart;\n    const instanceEnd = geometry.attributes.instanceEnd;\n    const lineDistances = new Float32Array(2 * instanceStart.count);\n    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {\n      _start.fromBufferAttribute(instanceStart, i);\n      _end.fromBufferAttribute(instanceEnd, i);\n      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);\n    }\n    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n    geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n    geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n    return this;\n  }\n\n  /**\n   * Computes intersection points between a casted ray and this instance.\n   *\n   * @param {Raycaster} raycaster - The raycaster.\n   * @param {Array<Object>} intersects - The target array that holds the intersection points.\n   */\n  raycast(raycaster, intersects) {\n    const worldUnits = this.material.worldUnits;\n    const camera = raycaster.camera;\n    if (camera === null && !worldUnits) {\n      console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');\n    }\n    const threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n    _ray = raycaster.ray;\n    const matrixWorld = this.matrixWorld;\n    const geometry = this.geometry;\n    const material = this.material;\n    _lineWidth = material.linewidth + threshold;\n\n    // check if we intersect the sphere bounds\n    if (geometry.boundingSphere === null) {\n      geometry.computeBoundingSphere();\n    }\n    _sphere.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);\n\n    // increase the sphere bounds by the worst case line screen space width\n    let sphereMargin;\n    if (worldUnits) {\n      sphereMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToSphere = Math.max(camera.near, _sphere.distanceToPoint(_ray.origin));\n      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);\n    }\n    _sphere.radius += sphereMargin;\n    if (_ray.intersectsSphere(_sphere) === false) {\n      return;\n    }\n\n    // check if we intersect the box bounds\n    if (geometry.boundingBox === null) {\n      geometry.computeBoundingBox();\n    }\n    _box.copy(geometry.boundingBox).applyMatrix4(matrixWorld);\n\n    // increase the box bounds by the worst case line width\n    let boxMargin;\n    if (worldUnits) {\n      boxMargin = _lineWidth * 0.5;\n    } else {\n      const distanceToBox = Math.max(camera.near, _box.distanceToPoint(_ray.origin));\n      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);\n    }\n    _box.expandByScalar(boxMargin);\n    if (_ray.intersectsBox(_box) === false) {\n      return;\n    }\n    if (worldUnits) {\n      raycastWorldUnits(this, intersects);\n    } else {\n      raycastScreenSpace(this, camera, intersects);\n    }\n  }\n  onBeforeRender(renderer) {\n    const uniforms = this.material.uniforms;\n    if (uniforms && uniforms.resolution) {\n      renderer.getViewport(_viewport);\n      this.material.uniforms.resolution.value.set(_viewport.z, _viewport.w);\n    }\n  }\n}\nexport { LineSegments2 };","map":{"version":3,"names":["Box3","InstancedInterleavedBuffer","InterleavedBufferAttribute","Line3","MathUtils","Matrix4","Mesh","Sphere","Vector3","Vector4","LineSegmentsGeometry","LineMaterial","_viewport","_start","_end","_start4","_end4","_ssOrigin","_ssOrigin3","_mvMatrix","_line","_closestPoint","_box","_sphere","_clipToWorldVector","_ray","_lineWidth","getWorldSpaceHalfWidth","camera","distance","resolution","set","applyMatrix4","projectionMatrix","multiplyScalar","w","x","width","y","height","projectionMatrixInverse","Math","abs","max","raycastWorldUnits","lineSegments","intersects","matrixWorld","geometry","instanceStart","attributes","instanceEnd","segmentCount","min","instanceCount","count","i","l","start","fromBufferAttribute","end","pointOnLine","point","distanceSqToSegment","isInside","distanceTo","push","origin","object","face","faceIndex","uv","uv1","raycastScreenSpace","material","near","at","matrixWorldInverse","z","copy","multiplyMatrices","isBehindCameraNear","deltaDist","t","lerp","param","closestPointToPointParameter","zPos","isInClipSpace","LineSegments2","constructor","arguments","length","undefined","color","random","isLineSegments2","type","computeLineDistances","lineDistances","Float32Array","j","instanceDistanceBuffer","setAttribute","raycast","raycaster","worldUnits","console","error","threshold","params","Line2","ray","linewidth","boundingSphere","computeBoundingSphere","sphereMargin","distanceToSphere","distanceToPoint","radius","intersectsSphere","boundingBox","computeBoundingBox","boxMargin","distanceToBox","expandByScalar","intersectsBox","onBeforeRender","renderer","uniforms","getViewport","value"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/globe.gl/node_modules/three/examples/jsm/lines/LineSegments2.js"],"sourcesContent":["import {\n\tBox3,\n\tInstancedInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tLine3,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tSphere,\n\tVector3,\n\tVector4\n} from 'three';\nimport { LineSegmentsGeometry } from './LineSegmentsGeometry.js';\nimport { LineMaterial } from './LineMaterial.js';\n\nconst _viewport = new Vector4();\n\nconst _start = new Vector3();\nconst _end = new Vector3();\n\nconst _start4 = new Vector4();\nconst _end4 = new Vector4();\n\nconst _ssOrigin = new Vector4();\nconst _ssOrigin3 = new Vector3();\nconst _mvMatrix = new Matrix4();\nconst _line = new Line3();\nconst _closestPoint = new Vector3();\n\nconst _box = new Box3();\nconst _sphere = new Sphere();\nconst _clipToWorldVector = new Vector4();\n\nlet _ray, _lineWidth;\n\n// Returns the margin required to expand by in world space given the distance from the camera,\n// line width, resolution, and camera projection\nfunction getWorldSpaceHalfWidth( camera, distance, resolution ) {\n\n\t// transform into clip space, adjust the x and y values by the pixel width offset, then\n\t// transform back into world space to get world offset. Note clip space is [-1, 1] so full\n\t// width does not need to be halved.\n\t_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\t_clipToWorldVector.x = _lineWidth / resolution.width;\n\t_clipToWorldVector.y = _lineWidth / resolution.height;\n\t_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );\n\t_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );\n\n\treturn Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );\n\n}\n\nfunction raycastWorldUnits( lineSegments, intersects ) {\n\n\tconst matrixWorld = lineSegments.matrixWorld;\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t_line.applyMatrix4( matrixWorld );\n\n\t\tconst pointOnLine = new Vector3();\n\t\tconst point = new Vector3();\n\n\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\t\tconst isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;\n\n\t\tif ( isInside ) {\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint,\n\t\t\t\tpointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\nfunction raycastScreenSpace( lineSegments, camera, intersects ) {\n\n\tconst projectionMatrix = camera.projectionMatrix;\n\tconst material = lineSegments.material;\n\tconst resolution = material.resolution;\n\tconst matrixWorld = lineSegments.matrixWorld;\n\n\tconst geometry = lineSegments.geometry;\n\tconst instanceStart = geometry.attributes.instanceStart;\n\tconst instanceEnd = geometry.attributes.instanceEnd;\n\tconst segmentCount = Math.min( geometry.instanceCount, instanceStart.count );\n\n\tconst near = - camera.near;\n\n\t//\n\n\t// pick a point 1 unit out along the ray to avoid the ray origin\n\t// sitting at the camera origin which will cause \"w\" to be 0 when\n\t// applying the projection matrix.\n\t_ray.at( 1, _ssOrigin );\n\n\t// ndc space [ - 1.0, 1.0 ]\n\t_ssOrigin.w = 1;\n\t_ssOrigin.applyMatrix4( camera.matrixWorldInverse );\n\t_ssOrigin.applyMatrix4( projectionMatrix );\n\t_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );\n\n\t// screen space\n\t_ssOrigin.x *= resolution.x / 2;\n\t_ssOrigin.y *= resolution.y / 2;\n\t_ssOrigin.z = 0;\n\n\t_ssOrigin3.copy( _ssOrigin );\n\n\t_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );\n\n\tfor ( let i = 0, l = segmentCount; i < l; i ++ ) {\n\n\t\t_start4.fromBufferAttribute( instanceStart, i );\n\t\t_end4.fromBufferAttribute( instanceEnd, i );\n\n\t\t_start4.w = 1;\n\t\t_end4.w = 1;\n\n\t\t// camera space\n\t\t_start4.applyMatrix4( _mvMatrix );\n\t\t_end4.applyMatrix4( _mvMatrix );\n\n\t\t// skip the segment if it's entirely behind the camera\n\t\tconst isBehindCameraNear = _start4.z > near && _end4.z > near;\n\t\tif ( isBehindCameraNear ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\t// trim the segment if it extends behind camera near\n\t\tif ( _start4.z > near ) {\n\n\t\t\tconst deltaDist = _start4.z - _end4.z;\n\t\t\tconst t = ( _start4.z - near ) / deltaDist;\n\t\t\t_start4.lerp( _end4, t );\n\n\t\t} else if ( _end4.z > near ) {\n\n\t\t\tconst deltaDist = _end4.z - _start4.z;\n\t\t\tconst t = ( _end4.z - near ) / deltaDist;\n\t\t\t_end4.lerp( _start4, t );\n\n\t\t}\n\n\t\t// clip space\n\t\t_start4.applyMatrix4( projectionMatrix );\n\t\t_end4.applyMatrix4( projectionMatrix );\n\n\t\t// ndc space [ - 1.0, 1.0 ]\n\t\t_start4.multiplyScalar( 1 / _start4.w );\n\t\t_end4.multiplyScalar( 1 / _end4.w );\n\n\t\t// screen space\n\t\t_start4.x *= resolution.x / 2;\n\t\t_start4.y *= resolution.y / 2;\n\n\t\t_end4.x *= resolution.x / 2;\n\t\t_end4.y *= resolution.y / 2;\n\n\t\t// create 2d segment\n\t\t_line.start.copy( _start4 );\n\t\t_line.start.z = 0;\n\n\t\t_line.end.copy( _end4 );\n\t\t_line.end.z = 0;\n\n\t\t// get closest point on ray to segment\n\t\tconst param = _line.closestPointToPointParameter( _ssOrigin3, true );\n\t\t_line.at( param, _closestPoint );\n\n\t\t// check if the intersection point is within clip space\n\t\tconst zPos = MathUtils.lerp( _start4.z, _end4.z, param );\n\t\tconst isInClipSpace = zPos >= - 1 && zPos <= 1;\n\n\t\tconst isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;\n\n\t\tif ( isInClipSpace && isInside ) {\n\n\t\t\t_line.start.fromBufferAttribute( instanceStart, i );\n\t\t\t_line.end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\t_line.start.applyMatrix4( matrixWorld );\n\t\t\t_line.end.applyMatrix4( matrixWorld );\n\n\t\t\tconst pointOnLine = new Vector3();\n\t\t\tconst point = new Vector3();\n\n\t\t\t_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );\n\n\t\t\tintersects.push( {\n\t\t\t\tpoint: point,\n\t\t\t\tpointOnLine: pointOnLine,\n\t\t\t\tdistance: _ray.origin.distanceTo( point ),\n\t\t\t\tobject: lineSegments,\n\t\t\t\tface: null,\n\t\t\t\tfaceIndex: i,\n\t\t\t\tuv: null,\n\t\t\t\tuv1: null,\n\t\t\t} );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * A series of lines drawn between pairs of vertices.\n *\n * This adds functionality beyond {@link LineSegments}, like arbitrary line width and changing width\n * to be in world units. {@link Line2} extends this object, forming a polyline instead of individual\n * segments.\n *\n * This module can only be used with {@link WebGLRenderer}. When using {@link WebGPURenderer},\n * import the class from `lines/webgpu/LineSegments2.js`.\n *\n *  ```js\n * const geometry = new LineSegmentsGeometry();\n * geometry.setPositions( positions );\n * geometry.setColors( colors );\n *\n * const material = new LineMaterial( { linewidth: 5, vertexColors: true } };\n *\n * const lineSegments = new LineSegments2( geometry, material );\n * scene.add( lineSegments );\n * ```\n *\n * @augments Mesh\n * @three_import import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';\n */\nclass LineSegments2 extends Mesh {\n\n\t/**\n\t * Constructs a new wide line.\n\t *\n\t * @param {LineSegmentsGeometry} [geometry] - The line geometry.\n\t * @param {LineMaterial} [material] - The line material.\n\t */\n\tconstructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {\n\n\t\tsuper( geometry, material );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isLineSegments2 = true;\n\n\t\tthis.type = 'LineSegments2';\n\n\t}\n\n\t/**\n\t * Computes an array of distance values which are necessary for rendering dashed lines.\n\t * For each vertex in the geometry, the method calculates the cumulative length from the\n\t * current point to the very beginning of the line.\n\t *\n\t * @return {LineSegments2} A reference to this instance.\n\t */\n\tcomputeLineDistances() {\n\n\t\t// for backwards-compatibility, but could be a method of LineSegmentsGeometry...\n\n\t\tconst geometry = this.geometry;\n\n\t\tconst instanceStart = geometry.attributes.instanceStart;\n\t\tconst instanceEnd = geometry.attributes.instanceEnd;\n\t\tconst lineDistances = new Float32Array( 2 * instanceStart.count );\n\n\t\tfor ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {\n\n\t\t\t_start.fromBufferAttribute( instanceStart, i );\n\t\t\t_end.fromBufferAttribute( instanceEnd, i );\n\n\t\t\tlineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];\n\t\t\tlineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );\n\n\t\t}\n\n\t\tconst instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1\n\n\t\tgeometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0\n\t\tgeometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes intersection points between a casted ray and this instance.\n\t *\n\t * @param {Raycaster} raycaster - The raycaster.\n\t * @param {Array<Object>} intersects - The target array that holds the intersection points.\n\t */\n\traycast( raycaster, intersects ) {\n\n\t\tconst worldUnits = this.material.worldUnits;\n\t\tconst camera = raycaster.camera;\n\n\t\tif ( camera === null && ! worldUnits ) {\n\n\t\t\tconsole.error( 'LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );\n\n\t\t}\n\n\t\tconst threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;\n\n\t\t_ray = raycaster.ray;\n\n\t\tconst matrixWorld = this.matrixWorld;\n\t\tconst geometry = this.geometry;\n\t\tconst material = this.material;\n\n\t\t_lineWidth = material.linewidth + threshold;\n\n\t\t// check if we intersect the sphere bounds\n\t\tif ( geometry.boundingSphere === null ) {\n\n\t\t\tgeometry.computeBoundingSphere();\n\n\t\t}\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );\n\n\t\t// increase the sphere bounds by the worst case line screen space width\n\t\tlet sphereMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tsphereMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );\n\t\t\tsphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );\n\n\t\t}\n\n\t\t_sphere.radius += sphereMargin;\n\n\t\tif ( _ray.intersectsSphere( _sphere ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t// check if we intersect the box bounds\n\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\tgeometry.computeBoundingBox();\n\n\t\t}\n\n\t\t_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );\n\n\t\t// increase the box bounds by the worst case line width\n\t\tlet boxMargin;\n\t\tif ( worldUnits ) {\n\n\t\t\tboxMargin = _lineWidth * 0.5;\n\n\t\t} else {\n\n\t\t\tconst distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );\n\t\t\tboxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );\n\n\t\t}\n\n\t\t_box.expandByScalar( boxMargin );\n\n\t\tif ( _ray.intersectsBox( _box ) === false ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( worldUnits ) {\n\n\t\t\traycastWorldUnits( this, intersects );\n\n\t\t} else {\n\n\t\t\traycastScreenSpace( this, camera, intersects );\n\n\t\t}\n\n\t}\n\n\tonBeforeRender( renderer ) {\n\n\t\tconst uniforms = this.material.uniforms;\n\n\t\tif ( uniforms && uniforms.resolution ) {\n\n\t\t\trenderer.getViewport( _viewport );\n\t\t\tthis.material.uniforms.resolution.value.set( _viewport.z, _viewport.w );\n\n\t\t}\n\n\t}\n\n}\n\nexport { LineSegments2 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}