{"ast":null,"code":"export default function earcut(data, holeIndices) {\n  let dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  let outerNode = linkedList(data, 0, outerLen, dim, true);\n  const triangles = [];\n  if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n  let minX, minY, invSize;\n  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n  // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n  if (data.length > 80 * dim) {\n    minX = data[0];\n    minY = data[1];\n    let maxX = minX;\n    let maxY = minY;\n    for (let i = dim; i < outerLen; i += dim) {\n      const x = data[i];\n      const y = data[i + 1];\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x > maxX) maxX = x;\n      if (y > maxY) maxY = y;\n    }\n\n    // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n    invSize = Math.max(maxX - minX, maxY - minY);\n    invSize = invSize !== 0 ? 32767 / invSize : 0;\n  }\n  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n  return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n  let last;\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n  } else {\n    for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n  if (!start) return start;\n  if (!end) end = start;\n  let p = start,\n    again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next) break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear) return;\n\n  // interlink polygon nodes in z-order\n  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n  let stop = ear;\n\n  // iterate through ears, slicing them one by one\n  while (ear.prev !== ear.next) {\n    const prev = ear.prev;\n    const next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n      removeNode(ear);\n\n      // skipping the next vertex leads to less sliver triangles\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n\n    // if we looped through the whole remaining polygon and can't find any more ears\n    if (ear === stop) {\n      // try filtering points and slicing again\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n        // if this didn't work, try curing all small self-intersections locally\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n        // as a last resort, try splitting the remaining polygon into two\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  // now make sure we don't have other points inside the potential ear\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox\n  const x0 = Math.min(ax, bx, cx),\n    y0 = Math.min(ay, by, cy),\n    x1 = Math.max(ax, bx, cx),\n    y1 = Math.max(ay, by, cy);\n  let p = c.next;\n  while (p !== a) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev,\n    b = ear,\n    c = ear.next;\n  if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n  const ax = a.x,\n    bx = b.x,\n    cx = c.x,\n    ay = a.y,\n    by = b.y,\n    cy = c.y;\n\n  // triangle bbox\n  const x0 = Math.min(ax, bx, cx),\n    y0 = Math.min(ay, by, cy),\n    x1 = Math.max(ax, bx, cx),\n    y1 = Math.max(ay, by, cy);\n\n  // z-order range for the current triangle bbox;\n  const minZ = zOrder(x0, y0, minX, minY, invSize),\n    maxZ = zOrder(x1, y1, minX, minY, invSize);\n  let p = ear.prevZ,\n    n = ear.nextZ;\n\n  // look for points inside the triangle in both directions\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n\n  // look for remaining points in decreasing z-order\n  while (p && p.z >= minZ) {\n    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n    p = p.prevZ;\n  }\n\n  // look for remaining points in increasing z-order\n  while (n && n.z <= maxZ) {\n    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n    n = n.nextZ;\n  }\n  return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n  let p = start;\n  do {\n    const a = p.prev,\n      b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i, p.i, b.i);\n\n      // remove two nodes involved\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  // look for a valid diagonal that divides the polygon into two\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        // split the polygon in two by the diagonal\n        let c = splitPolygon(a, b);\n\n        // filter colinear points around the cuts\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n\n        // run earcut on each half\n        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  for (let i = 0, len = holeIndices.length; i < len; i++) {\n    const start = holeIndices[i] * dim;\n    const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    const list = linkedList(data, start, end, dim, false);\n    if (list === list.next) list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareXYSlope);\n\n  // process holes from left to right\n  for (let i = 0; i < queue.length; i++) {\n    outerNode = eliminateHole(queue[i], outerNode);\n  }\n  return outerNode;\n}\nfunction compareXYSlope(a, b) {\n  let result = a.x - b.x;\n  // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n  // the bridge to the outer shell is always the point that they meet at.\n  if (result === 0) {\n    result = a.y - b.y;\n    if (result === 0) {\n      const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n      const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n      result = aSlope - bSlope;\n    }\n  }\n  return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n  const bridge = findHoleBridge(hole, outerNode);\n  if (!bridge) {\n    return outerNode;\n  }\n  const bridgeReverse = splitPolygon(bridge, hole);\n\n  // filter collinear points around the cuts\n  filterPoints(bridgeReverse, bridgeReverse.next);\n  return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity;\n  let m;\n\n  // find a segment intersected by a ray from the hole's leftmost point to the left;\n  // segment's endpoint with lesser x will be potential connection point\n  // unless they intersect at a vertex, then choose the vertex\n  if (equals(hole, p)) return p;\n  do {\n    if (equals(hole, p.next)) return p.next;else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        m = p.x < p.next.x ? p : p.next;\n        if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m) return null;\n\n  // look for points inside the triangle of hole point, segment intersection and endpoint;\n  // if there are no points found, we have a valid connection;\n  // otherwise choose the point of the minimum angle with the ray as connection point\n\n  const stop = m;\n  const mx = m.x;\n  const my = m.y;\n  let tanMin = Infinity;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n  let numMerges;\n  let inSize = 1;\n  do {\n    let p = list;\n    let e;\n    list = null;\n    let tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      let q = p;\n      let pSize = 0;\n      for (let i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q) break;\n      }\n      let qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail) tail.nextZ = e;else list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n  // coords are transformed into non-negative 15-bit integer range\n  x = (x - minX) * invSize | 0;\n  y = (y - minY) * invSize | 0;\n  x = (x | x << 8) & 0x00FF00FF;\n  x = (x | x << 4) & 0x0F0F0F0F;\n  x = (x | x << 2) & 0x33333333;\n  x = (x | x << 1) & 0x55555555;\n  y = (y | y << 8) & 0x00FF00FF;\n  y = (y | y << 4) & 0x0F0F0F0F;\n  y = (y | y << 2) & 0x33333333;\n  y = (y | y << 1) & 0x55555555;\n  return x | y << 1;\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n  let p = start,\n    leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (\n  // doesn't intersect other edges\n  locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (\n  // locally visible\n  area(a.prev, a, b.prev) || area(a, b.prev, b)) ||\n  // does not create opposite-facing sectors\n  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4) return true; // general case\n\n  if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n  if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n  return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n  let p = a;\n  let inside = false;\n  const px = (a.x + b.x) / 2;\n  const py = (a.y + b.y) / 2;\n  do {\n    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n  const a2 = createNode(a.i, a.x, a.y),\n    b2 = createNode(b.i, b.x, b.y),\n    an = a.next,\n    bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n  const p = createNode(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\nfunction createNode(i, x, y) {\n  return {\n    i,\n    // vertex index in coordinates array\n    x,\n    y,\n    // vertex coordinates\n    prev: null,\n    // previous and next vertex nodes in a polygon ring\n    next: null,\n    z: 0,\n    // z-order curve value\n    prevZ: null,\n    // previous and next nodes in z-order\n    nextZ: null,\n    steiner: false // indicates whether this is a steiner point\n  };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n  const hasHoles = holeIndices && holeIndices.length;\n  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n  let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n  if (hasHoles) {\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n      const start = holeIndices[i] * dim;\n      const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n      polygonArea -= Math.abs(signedArea(data, start, end, dim));\n    }\n  }\n  let trianglesArea = 0;\n  for (let i = 0; i < triangles.length; i += 3) {\n    const a = triangles[i] * dim;\n    const b = triangles[i + 1] * dim;\n    const c = triangles[i + 2] * dim;\n    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n  }\n  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n  return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n  const vertices = [];\n  const holes = [];\n  const dimensions = data[0][0].length;\n  let holeIndex = 0;\n  let prevLen = 0;\n  for (const ring of data) {\n    for (const p of ring) {\n      for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n    }\n    if (prevLen) {\n      holeIndex += prevLen;\n      holes.push(holeIndex);\n    }\n    prevLen = ring.length;\n  }\n  return {\n    vertices,\n    holes,\n    dimensions\n  };\n}","map":{"version":3,"names":["earcut","data","holeIndices","dim","arguments","length","undefined","hasHoles","outerLen","outerNode","linkedList","triangles","next","prev","minX","minY","invSize","eliminateHoles","maxX","maxY","i","x","y","Math","max","earcutLinked","start","end","clockwise","last","signedArea","insertNode","equals","removeNode","filterPoints","p","again","steiner","area","ear","pass","indexCurve","stop","isEarHashed","isEar","push","cureLocalIntersections","splitEarcut","a","b","c","ax","bx","cx","ay","by","cy","x0","min","y0","x1","y1","pointInTriangleExceptFirst","minZ","zOrder","maxZ","prevZ","n","nextZ","z","intersects","locallyInside","isValidDiagonal","splitPolygon","queue","len","list","getLeftmost","sort","compareXYSlope","eliminateHole","result","aSlope","bSlope","hole","bridge","findHoleBridge","bridgeReverse","hx","hy","qx","Infinity","m","mx","my","tanMin","pointInTriangle","tan","abs","sectorContainsSector","sortLinked","numMerges","inSize","e","tail","q","pSize","qSize","leftmost","px","py","intersectsPolygon","middleInside","r","p1","p2","q1","q2","o1","sign","o2","o3","o4","onSegment","num","inside","a2","createNode","b2","an","bp","deviation","polygonArea","trianglesArea","sum","j","flatten","vertices","holes","dimensions","holeIndex","prevLen","ring","d"],"sources":["/Users/Nils_1/Downloads/casa-react-v2/node_modules/earcut/src/earcut.js"],"sourcesContent":["\nexport default function earcut(data, holeIndices, dim = 2) {\n\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    let minX, minY, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = data[0];\n        minY = data[1];\n        let maxX = minX;\n        let maxY = minY;\n\n        for (let i = dim; i < outerLen; i += dim) {\n            const x = data[i];\n            const y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 32767 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    let last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    } else {\n        for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    let stop = ear;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        const prev = ear.prev;\n        const next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            triangles.push(prev.i, ear.i, next.i); // cut off the triangle\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    let p = c.next;\n    while (p !== a) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    const a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;\n\n    // triangle bbox\n    const x0 = Math.min(ax, bx, cx),\n        y0 = Math.min(ay, by, cy),\n        x1 = Math.max(ax, bx, cx),\n        y1 = Math.max(ay, by, cy);\n\n    // z-order range for the current triangle bbox;\n    const minZ = zOrder(x0, y0, minX, minY, invSize),\n        maxZ = zOrder(x1, y1, minX, minY, invSize);\n\n    let p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c &&\n            pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles) {\n    let p = start;\n    do {\n        const a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i, p.i, b.i);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    let a = start;\n    do {\n        let b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                let c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);\n                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    const queue = [];\n\n    for (let i = 0, len = holeIndices.length; i < len; i++) {\n        const start = holeIndices[i] * dim;\n        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        const list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareXYSlope);\n\n    // process holes from left to right\n    for (let i = 0; i < queue.length; i++) {\n        outerNode = eliminateHole(queue[i], outerNode);\n    }\n\n    return outerNode;\n}\n\nfunction compareXYSlope(a, b) {\n    let result = a.x - b.x;\n    // when the left-most point of 2 holes meet at a vertex, sort the holes counterclockwise so that when we find\n    // the bridge to the outer shell is always the point that they meet at.\n    if (result === 0) {\n        result = a.y - b.y;\n        if (result === 0) {\n            const aSlope = (a.next.y - a.y) / (a.next.x - a.x);\n            const bSlope = (b.next.y - b.y) / (b.next.x - b.x);\n            result = aSlope - bSlope;\n        }\n    }\n    return result;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and link it\nfunction eliminateHole(hole, outerNode) {\n    const bridge = findHoleBridge(hole, outerNode);\n    if (!bridge) {\n        return outerNode;\n    }\n\n    const bridgeReverse = splitPolygon(bridge, hole);\n\n    // filter collinear points around the cuts\n    filterPoints(bridgeReverse, bridgeReverse.next);\n    return filterPoints(bridge, bridge.next);\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    let p = outerNode;\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    // unless they intersect at a vertex, then choose the vertex\n    if (equals(hole, p)) return p;\n    do {\n        if (equals(hole, p.next)) return p.next;\n        else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                m = p.x < p.next.x ? p : p.next;\n                if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            const tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    let p = start;\n    do {\n        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    let numMerges;\n    let inSize = 1;\n\n    do {\n        let p = list;\n        let e;\n        list = null;\n        let tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            let q = p;\n            let pSize = 0;\n            for (let i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            let qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = (x - minX) * invSize | 0;\n    y = (y - minY) * invSize | 0;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    let p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) &&\n           (ax - px) * (by - py) >= (bx - px) * (ay - py) &&\n           (bx - px) * (cy - py) >= (cx - px) * (by - py);\n}\n\n// check if a point lies within a convex triangle but false if its equal to the first point of the triangle\nfunction pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {\n    return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    const o1 = sign(area(p1, q1, p2));\n    const o2 = sign(area(p1, q1, q2));\n    const o3 = sign(area(p2, q2, p1));\n    const o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    let p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    const a2 = createNode(a.i, a.x, a.y),\n        b2 = createNode(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    const p = createNode(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction createNode(i, x, y) {\n    return {\n        i, // vertex index in coordinates array\n        x, y, // vertex coordinates\n        prev: null, // previous and next vertex nodes in a polygon ring\n        next: null,\n        z: 0, // z-order curve value\n        prevZ: null, // previous and next nodes in z-order\n        nextZ: null,\n        steiner: false // indicates whether this is a steiner point\n    };\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nexport function deviation(data, holeIndices, dim, triangles) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (let i = 0; i < triangles.length; i += 3) {\n        const a = triangles[i] * dim;\n        const b = triangles[i + 1] * dim;\n        const c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n}\n\nfunction signedArea(data, start, end, dim) {\n    let sum = 0;\n    for (let i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nexport function flatten(data) {\n    const vertices = [];\n    const holes = [];\n    const dimensions = data[0][0].length;\n    let holeIndex = 0;\n    let prevLen = 0;\n\n    for (const ring of data) {\n        for (const p of ring) {\n            for (let d = 0; d < dimensions; d++) vertices.push(p[d]);\n        }\n        if (prevLen) {\n            holeIndex += prevLen;\n            holes.push(holeIndex);\n        }\n        prevLen = ring.length;\n    }\n    return {vertices, holes, dimensions};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}